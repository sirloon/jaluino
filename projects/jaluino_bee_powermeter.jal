-- Title: Powermeter with Jaluino Bee.
-- Author: Sebastien Lelong, Copyright (c) 2011, all rights reserved.
-- Adapted-by:
-- Compiler: 2.4o
--
-- This file is part of jaluino (http://jaluino.googlecode.com)
-- Released under the BSD license (http://www.opensource.org/licenses/bsd-license.php)
--
-- Description: Some electrical counter device has a flashing LED giving information
-- about current consumption. This program uses a phototransistor connected on RA1,
-- and detect these flashes, using interrupts. Each flash increments a counter.
-- Using Realtime clock & calendar peripheral, it triggers some alarm events
-- on regular basis, and send flash count through serial. This allows to collect
-- flash count each minute, for instance.
-- .
-- Also added DHT11 sensor...
-- Also added LDR light sensor...
--

-- chip setup
include jaluino_bee

-- enable watchdog, it must be cleared within ~4s
-- before PIC gets reset
pragma target WDT  enabled
pragma target WDTPS P1K

include delay
include print

onboard_led_direction = output
onboard_led =  off

-- map INT1 on RA1 (which is remappable pin RP1)
pps_control_lock(false)
PPS_MAP_INT1 = RP1
pps_control_lock(true)


const SERIAL_HW_BAUDRATE = 9600
include serial_hardware
serial_hw_init()

const byte STR_FLASH[] = "!Flash: "
const byte STR_TEMP[] = "!Temperature: "
const byte STR_HUM[] = "!Humidity: "
const byte STR_LIGHT[] = "!Light: "
const byte STR_WELCOME[] = "Power Meter"
const byte STR_DATETIME[] = "?datetime "
const byte STR_OK[] = "!OK"

print_string(serial_hw_data,STR_WELCOME)
print_crlf(serial_hw_data)

alias pin_dht11_direction is pin_A3_direction
alias pin_dht11 is pin_A3
include temperature_humidity_dht11


include rtcc_hw

-- RTC can be calibrated, 32KHz Xtal must be measured
-- in order to determine the deviation. This is specific to 
-- the crystal itself. We're assuming no deviation.
rtc_calibrate(0)

-- set up interrupts
INTCON3_INT1IE = on -- allow interrupt from changing state on INT1
INTCON3_INT1IF = off -- flush flag of interrupt from INT1
INTCON2_INTEDG1 = 0 -- setting up interrupt INT1 from changing state 1->0
                    -- this corresponds to no-light -> light
-- Set interrupts so we can react when alarm is ringing
PIE3_RTCCIE = enabled
-- allow interrupts
INTCON_GIE = on
INTCON_PEIE = on

var byte year
var byte month
var byte day
var byte hour
var byte minute
var byte second

var byte _trash -- used to ignore returned values

var word flash_count
var word light = 0
var word max_light = 0
var bit do_send_data = false


-- Configure ADC
const byte ADC_NVREF = ADC_NO_EXT_VREF
const word ADC_RSOURCE = 2_000
const bit ADC_HIGH_RESOLUTION = high
include adc
adc_init()
set_analog_pin(4) -- RA5/AN*4*


procedure int_isr() is
   pragma interrupt
   
   -- INT1 interrupt: there was a flash
   if INTCON3_INT1IF then
      onboard_led = !onboard_led
      flash_count = flash_count + 1
      -- debounce trigger to avoid counting this flash more than once
      delay_1ms(10)
      INTCON3_INT1IF = off -- flushing flag
   end if
   
   -- RTC interrupts: need to send flash count value
   if PIR3_RTCCIF then
      do_send_data = true
      PIR3_RTCCIF = false -- clear flag
   end if

end procedure

-- convert string numbers to BCD numbers
-- (eg. "11" becomes 0x11, in HEX)
procedure str2num(byte out num) is
   var byte char
   char = serial_hw_data
   serial_hw_data = char -- echo
   num = (char - "0") << 4
   char = serial_hw_data
   serial_hw_data = char -- echo
   num = num + (char - "0")
end procedure

-- request datetime to PC, though serial. PC must reply
-- the following format: "YY-MM-DD hh:mm:ss"
procedure set_datetime() is
   print_string(serial_hw_data,STR_DATETIME)
   print_crlf(serial_hw_data)
   -- year
   str2num(year)
   serial_hw_data = serial_hw_data -- sep "-"
   -- month
   str2num(month)
   serial_hw_data = serial_hw_data -- sep "-"
   -- day
   str2num(day)
   serial_hw_data = serial_hw_data -- space
   -- hour
   str2num(hour)
   serial_hw_data = serial_hw_data -- sep ":"
   -- minute
   str2num(minute)
   serial_hw_data = serial_hw_data -- sep ":"
   --second
   str2num(second)
   
   -- got everything needed, let's set date & time
   rtc_set_date(year,month,day)           -- YY/MM/DD )
   rtc_set_time(hour,minute,minute)           -- HH:MM:SS ) BCD format
   rtc_set_alarm_time(hour,minute,second)     -- HH:MM:SS )
   rtc_set_alarm_interval(RTC_ALARM_INTERVAL_MINUTE)
   rtc_set_alarm_repeat(255)
   rtc_set_alarm(ON)                      -- enable alarm
   rtc_set_clock(ON)                      -- enable RTCC module

   -- ACK time setting
   print_crlf(serial_hw_data)
   print_string(serial_hw_data,STR_OK)
   print_crlf(serial_hw_data)
end procedure

set_datetime()

-- main loop
forever loop

   if do_send_data then
   
      do_send_data = false
      print_crlf(serial_hw_data)
      rtc_get_date(year,month,day)
      rtc_get_time(hour,minute,second)
      print_string(serial_hw_data,STR_FLASH)
      print_byte_hex(serial_hw_data,year)
      serial_hw_data = "-"
      print_byte_hex(serial_hw_data,month)
      serial_hw_data = "-"
      print_byte_hex(serial_hw_data,day)
      serial_hw_data = " "
      print_byte_hex(serial_hw_data,hour)
      serial_hw_data = ":"
      print_byte_hex(serial_hw_data,minute)
      serial_hw_data = ":"
      print_byte_hex(serial_hw_data,second)
      serial_hw_data = "|"
      print_word_dec(serial_hw_data,flash_count)
      print_crlf(serial_hw_data)
      -- reset flash counter
      flash_count = 0
      
      -- get temp/hum value
      if(dht11_read() == DHT11_OK) then
         print_string(serial_hw_data,STR_TEMP)
         print_byte_dec(serial_hw_data,dht11_temperature)
         print_crlf(serial_hw_data)
         print_string(serial_hw_data,STR_HUM)
         print_byte_dec(serial_hw_data,dht11_humidity)
         print_crlf(serial_hw_data)
      end if

      -- send highest light value found during delay
      print_string(serial_hw_data,STR_LIGHT)
      print_word_dec(serial_hw_data,max_light)
      print_crlf(serial_hw_data)
      -- reset max value
      max_light = 0

   end if
   
   -- light: we're trying to capture higher values during one minute
   -- that is, the max value from 60 readings
   light = adc_read(4)
   if light >= max_light then
      max_light = light
   end if
   
   delay_1s(1)
   serial_hw_data = "."
   -- we're alive, so clear watchdog
   asm clrwdt
   
end loop

