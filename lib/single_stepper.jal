-- ------------------------------------------------------
-- Title: single stepper shield library
-- Author: Richard Zengerink, Copyright (c) 2009..2010, all rights reserved.
--
-- Adapted-by:
--
-- Compiler: 2.4l
--
-- This file is part of jaluino  (http://jaluino.googlecode.com)
-- Released under the BSD license (http://www.opensource.org/licenses/bsd-license.php)
--
-- Description: this library can be used with single stepper shield
--
-- Sources:
--
-- Notes:
--
-- variable declare in main program:
-- const word step_rate = 200            -- number of steps per rotation from stepper motor
--
-- pin assignments


   var volatile bit    single_stepper_led                is pin_a0           -- D5
   var volatile bit    single_stepper_led_direction      is pin_a0_direction
   var volatile bit    single_stepper_switch1            is pin_d6           -- SW1
   var volatile bit    single_stepper_switch1_direction  is pin_d6_direction
   var volatile bit    single_stepper_switch2            is pin_d7           -- SW2
   var volatile bit    single_stepper_switch2_direction  is pin_d7_direction
   var volatile bit    single_stepper_phase1             is pin_b0           -- phase coil1
   var volatile bit    single_stepper_phase1_direction   is pin_b0_direction
   var volatile bit    single_stepper_phase2             is pin_b1           -- phase coil2
   var volatile bit    single_stepper_phase2_direction   is pin_b1_direction
   var volatile bit    single_stepper_coil1              is pin_b2           -- coil1 enable
   var volatile bit    single_stepper_coil1_direction    is pin_b2_direction
   var volatile bit    single_stepper_coil2              is pin_b3           -- coil2 enable
   var volatile bit    single_stepper_coil2_direction    is pin_b3_direction

   var byte stepper_control  is  portb_low   -- low nibbel of portb is used to drive the stepper


   single_stepper_led_direction      = output    -- Led D5
   single_stepper_switch1_direction  = output    -- switch SW1
   single_stepper_switch2_direction  = output    -- switch SW2
   single_stepper_phase1_direction   = output    -- direction of current in coil1
   single_stepper_phase2_direction   = output    -- direction of current in coil2
   single_stepper_coil1_direction    = output    -- enable (Enegize) coil1
   single_stepper_coil2_direction    = output    -- enable (Enegize) coil2


--
--------- timer0-----------
-- timer0 use for driving steppermotor
--
T0CON = 0b0000_0000
-- T0CON_TMR0ON     at T1CON : 7  = 0     1 = enables T0, 0 = stops T0
-- T0CON_T08BIT     at T1CON : 6  = 0     1 = T0 is 8bit, 0 = T0 is 16bit
-- T0CON_T0CS       at T1CON : 5  = 0     source, 1 = T0CKI pin, 0 = Foc/4
-- T0CON_T0SE       at T1CON : 4  = 0     1 = H=>L on T0CKI pin, 0 = L=>H on T0CKI pin
-- T0CON_PSA        at T1CON : 3  = 0     1 = no prescaller,  0 = with prescaler
-- T0CON_T0PS       at T1CON : 0  = 0     T0PS * 3 is prescaler
--
-- in is Foc/4
-- with 200 stepper motor max rpm =
-- (48_000_000/4/prescaler/TMR0_register(min)/step_rate)* 60Sec
-- = (48_000_000/4/2/(TMR1L*TMR1H)(min)/200)*60 = (12_000_000/2/1/200)*60 =
-- 30000*60 = 1800000 rpm (!)
--
-- with 200 stepper motor min rpm =
-- (48_000_000/4/prescaler/TMR0_register(max)/step_rate)* 60Sec
-- = (48_000_000/4/256/(TMR1L*TMR1H)(max)/200)*60 = (12_000_000/256/65535/200)*60 =
-- 0.00358*60 = 0.21 rpm (!)
--
-- better keep speed setting between 0.3 to 1000 rpm



--
--------- timer1-----------
-- timer1 for 0.01Sec timing interupt
T1CON = 0b0011_0000
-- T1CON_RD16       at T1CON : 7  = 0     1 = register rd/wr in one 16 bit operation
--                                        0 = register rd/wr in two 8 bit operation
-- T1CON_T1RUN      at T1CON : 6  = 0     1 = device clock derived from T1 oscillator
--                                        0 = device clock derived from another source
-- T1CON_T1CKPS     at T1CON : 4  = 1     T1CKPS * 2 prescaler  1,2,4,8
-- T1CON_T1OSCEN    at T1CON : 3  = 0     1 = osc is enabled 0 = osc is shut off
-- T1CON_NT1SYNC    at T1CON : 2  = 0     1 = do not sync ext. clk  0 = sync ext.clk
-- T1CON_TMR1CS     at T1CON : 1  = 0     1 = ext. clock 0 = int. clock (Fosc/4)
-- T1CON_TMR1ON     at T1CON : 0  = 0     1 = enables timer1 0 =  disables timer 1
--
-- in is Foc/4
-- set timer1 at 0.01Sec =  48_000_000/4/prescaler = 48_000_000/4/8 = 1500000
-- 1500000 * 0.01Sec = 15000/256 = 58,5.. so TMR1H = 256-58 = 198
-- 58 x 256 = 14848, 15000 - 14848 = 152 so TMR1L = 256-152 = 104
-- total result is (20_000_000/4/8/((24*256) + 106) = 100.0Hz is 0.01Sec
--


------------- Variable -----------------------------------------------
   var bit cw = true          -- cw = true is clockwise false = counter clockwise
   var bit full_step = true   -- if true than full step not true then half step
   var bit accel_active = true -- is set during acceleration
   var bit decel_active = true -- is set during deceleration
   var bit high_prescal = false -- wil be set when prescaler is 256 and reset at 2
   var bit run = false          -- is set during run and reset after stop
   var bit stop = false         -- is set during stop ramp and reset after stop


   var byte steppointer = 0   -- points to position in full_step or half_step array

----------------------------------------------ONLY TEST ----------------------------------------------
var byte teller = 0 ------ALLEEN TEST
----------------------------------------------------------------------------------------------------------

   var word accel_ramp = 0       -- holds acceleration ramp in pulses/Sec2
   var word decel_ramp = 0       -- holds deceleration ramp in pulses/Sec2
   var word tmr1register = 0  -- holds actual 16bit value for TMR1L and TMR1H
   var word tmr1register_new = 0  -- holds 16bit new calculated value for TMR1L and TMR1H

   var dword pulses_sec = 0   -- holds calculation of number of pulses per second


   var sdword distance = 100   -- holds distance in pulses


   if defined(step_rate)== false then
       PRAGMA ERROR -- Variable step_rate not defined in main program
   end if
   
-- -------------------------------------------------------------------
-- Bit patern for full step
-- -------------------------------------------------------------------

   const byte full_step_array[4] =   --  Bit patern for full step
    {
    0b0000_0001,        -- 0000
    0b0000_0011,        -- 0001
    0b0000_0010,        -- 0011
    0b0000_0000         -- 0010
    }


-- -------------------------------------------------------------------
-- Bit patern for half step
-- -------------------------------------------------------------------

   const byte half_step_array[8] =  -- !!!!!! CHECK !!!!!   bit patern for half step
    {
    0b0000_1001,
    0b0000_0011,
    0b0000_0110,
    0b0000_0010,
    0b0000_1000,
    0b0000_0000,
    0b0000_0100,
    0b0000_0001
    }



  ------------------------------------------------------------------------
  ------------- interupt Procedures --------------------------------------
  ------------------------------------------------------------------------

  INTCON2_TMR0IP = on      -- set high priority interrupt on timer0


------------   Interupt Timer 0  1 delay between steps   -----------------
  procedure timer0() is
    pragma interrupt
    if !INTCON_TMR0IF then return end if -- if not timer0 flag then exit
 -- first load TMR0H and than TMR0L because register load 16bit in one, on TMR0L load
    TMR0H = 256 -(tmr1register >> 8)  -- shift high byte to low byte on tmr1register
                                       -- and reload TMR1H with now low byte
    TMR0L = 256 - tmr1register -- reload TMR1L from low byte original tmr1register
                                       -- at this moment complete 16bit wil be loaded in register
    if full_step then
       stepper_control = full_step_array[steppointer]  -- output half step
    else
       stepper_control = half_step_array[steppointer]  -- output next full step
    end if


    if cw then                       -- select next step, depending on rotation and step size
       if steppointer == 0 then
          if full_step then
             steppointer = 3
          else
             steppointer = 7
          end if
       else
          steppointer = steppointer - 1
       end if
    else
       if full_step then
          if steppointer == 3 then
             steppointer = 0
          else
             steppointer = steppointer + 1
          end if
       else
          if steppointer == 7 then
              steppointer = 0
          else
              steppointer = steppointer + 1
          end if
       end if
     end if
--------------------------TEST ONLY ------------------------------------------------------
if scoop_a1 then
   scoop_a1 = off
else
   scoop_a1 = on
end if
-----------------------------------------------------------------------------------------

    INTCON_TMR0IF = off    -- clear interupt flag for next interrupt
  end procedure
 ------------------------------------------------------





 ---------------- Interupt Timer   =>  0.01Sec  ---------------------
  procedure timer1() is
    pragma interrupt
    if !PIR1_TMR1IF then return end if -- if not timer1 flag then exit
single_stepper_led = on
--------------------------TEST ONLY ------------------------------------------------------
if scoop_a2 then
   scoop_a2 = off
else
   scoop_a2 = on
end if
-----------------------------------------------------------------------------------------


    var dword calculate = 0   -- use for calculation of register with 2 decimals
    TMR1H = 198            -- set timer register for start 0.01Sec  256-58 = 198
    TMR1L = 104            -- 256-152 = 104

-- manipulate tmr1register for acceleration or decelaretion
    if stop | decel_active then
       calculate = (dword(tmr1register) * 100)+ dword(decel_ramp) -- * 100 for
                                             -- calculating with 2 decimals
       calculate = calculate / 100           -- back to normal value
       if calculate > 65535 then  -- check for maximum register
          if high_prescal then   -- high prescaler means lowest possible speed
             if stop then
                stop = false    -- if stop dan reset flag
                run = false     -- if stop dan reset flag
                T0CON_TMR0ON = off     -- stop timer0 and thus stop steppermotor
                INTCON_TMR0IE = off    -- disable timer0 interupt
                decel_active = false        -- reset
                accel_active = false        -- reset
                T1CON_TMR1ON = off     -- set timer1 off
                PIE1_TMR1IE = off      -- disable timer1 interrupt
                PIR1_TMR1IF = off      -- clear interupt flag
             else
                tmr1register = 65535 -- set register for slowest possible speed
                T1CON_TMR1ON = off     -- set timer1 off
                PIE1_TMR1IE = off      -- disable timer1 interrupt
                PIR1_TMR1IF = off      -- clear interupt flag
             end if
          else                   -- set prescaler for lowes speed section
             T0CON = 0b0000_0111  -- prescaler => 256
             high_prescal = true
             tmr1register = 515 -- is about the same speed as tmr1register = 65535
                                -- at prescaler on 2
          end if
          return
       end if
       if decel_active then
          if (high_prescal & pulses_sec > 100) | (tmr1register_new > calculate) then
             tmr1register = word(calculate) -- if in wrong speed section then or
          else                        -- speed not yet reacht then increase register
             tmr1register = tmr1register_new -- right speed now so stop decelaration
             decel_active = false
             T1CON_TMR1ON = off     -- set timer1 off
             PIE1_TMR1IE = off      -- disable timer1 interrupt
             PIR1_TMR1IF = off      -- clear interupt flag
             return
          end if
       end if
    end if

    if accel_active then
       calculate = (dword(tmr1register) * 100)- dword(accel_ramp)-- * 100 for
                                             -- calculating with 2 decimals

       if calculate <  tmr1register_new then  -- check if speed arrived



          T0CON_TMR0ON = off     -- stop timer0 and thus stop steppermotor
          INTCON_TMR0IE = off    -- disable timer0 interupt
          run = false
          stop = false           -- reset flag
          decel_active = false        -- reset
          accel_active = false        -- reset
          T1CON_TMR1ON = off     -- set timer1 off
          PIE1_TMR1IE = off      -- disable timer1 interrupt
          PIR1_TMR1IF = off      -- clear interupt flag
       end if
    end if


    PIR1_TMR1IF = off     -- clear interupt flag for next interrupt
  end procedure
 ------------------------------------------------------

  ------------------------------------------------------------------------
  ------------- Procedures -----------------------------------------------
  ------------------------------------------------------------------------
  
  
  procedure _timer0_01s_on()  is
    INTCON_PEIE = 1        -- Peripheral interupt enabled
    INTCON_GIE = 1         -- general interupt enabled
    TMR1H = 198            -- set timer register for start 0.01Sec  256-58 = 198
    TMR1L = 104            -- 256-152 = 104
    T1CON_TMR1ON = on      -- set timer1 on
    PIR1_TMR1IF = off      -- clear interupt flag for next interrupt
    PIE1_TMR1IE = on       -- enable timer1 interrupt
  end procedure


  procedure _timer0_01s_off()  is
    T1CON_TMR1ON = off     -- set timer1 off
    PIE1_TMR1IE = off      -- disable timer1 interrupt
    PIR1_TMR1IF = off      -- clear interupt flag
  end procedure


  procedure hold_stepper() is  -- steppermotor stop direct
    T0CON_TMR0ON = off     -- stop timer0 and thus stop steppermotor
    INTCON_TMR0IE = off    -- disable timer0 interupt
    run = false
    stop = false           -- reset flag
    decel_active = false        -- reset
    accel_active = false        -- reset
    _timer0_01s_off()
  end procedure
  

  procedure disable_stepper()  is
    hold_stepper()
    single_stepper_coil1 = on         --high is deactivated coil
    single_stepper_coil2 = on         --high is deactivated coil
  end procedure

  procedure enable_stepper()  is
    single_stepper_coil1 = off        --low is activated coil
    single_stepper_coil2 = off        --low is activated coil
  end procedure




  procedure velocity(word in data) is  -- sets new tmr1register for new velocity
     if full_step then           -- pulses_sec = (rpm*step_rate)/60Sec at full step
        pulses_sec = (dword(data) * dword(step_rate))/600  -- pulses_sec holds pulsrate
     else                        -- at velocity on full step. velocity in 0.1rpm => 60*10 = 600
        pulses_sec = (dword(data) * dword(step_rate))/300  -- pulses_sec holds pulsrate
     end if                      -- at velocity on half step. velocity in 0.1rpm => 60*10/2 = 300



     T0CON_TMR0ON = off     -- stop timer0 and thus stop steppermotor
     INTCON_TMR0IE = off    -- disable timer0 interupt

     if pulses_sec > 100 then    -- select higher prescaler for low speed
        T0CON = 0b0000_0000  -- prescaler => 2
        high_prescal = false
     else
        T0CON = 0b0000_0111  -- prescaler => 256
        high_prescal = true
     end if

     if high_prescal then
        tmr1register_new = word(target_clock/4/256/pulses_sec) -- prescaler is 256 so divide by 256
     else
        tmr1register_new = word(target_clock/4/2/pulses_sec)  -- prescaler is 2 so divide by 2
     end if


  end procedure






  procedure run_stepper(word in data) is  -- stepper speeding up in accel time to velocity speed

     velocity(data)
     
     if run | stop then                   -- data in is velocity speed in 0.1Sec
        T0CON_TMR0ON = on     -- start timer0 was stopped bij _velocity(data)
        INTCON_TMR0IE = on    -- enable timer0 interupt was disabled bij _velocity(data)
        stop = false                      -- if stop or ramping stop both
        _timer0_01s_off()
        if data == 0 then
           hold_stepper()
           return
        end if
        if tmr1register > tmr1register_new then     -- if tmr1register > tmr1register_new
           if accel_ramp == 0 then                  -- than new speed is faster
              tmr1register = tmr1register_new
           else
              accel_active = true        -- set during acceleration
              decel_active = false        -- reset
              _timer0_01s_on()           -- start timer1 for ramping up
           end if
        elsif tmr1register < tmr1register_new then  -- if tmr1register < tmr1register_new
           if decel_ramp == 0 then                  -- than new speed is slower
              tmr1register = tmr1register_new
           else
              decel_active = true        -- set during deceleration
              accel_active = false       -- reset
              _timer0_01s_on()           -- start timer1 for ramping down
           end if
           -- if tmr1register = tmr1register_new than no action, same speed
        end if

        run = true
        return
     end if

     run = true

     if accel_ramp == 0 then     -- no accel so set timer0 registers for velosity speed
        tmr1register = tmr1register_new   -- set tmr1register_new in tmr1register
        TMR0H = 255            -- set register as high as posible to go fast to timer0 interupt
        TMR0L = 255
        T0CON_TMR0ON = on      -- start timer0 and thus start steppermotor
        INTCON_TMR0IE = on     -- enable timer0 interupt

print_word_dec(usb_serial_data,tmr1register)
usb_serial_data = 13

        return
     end if
single_stepper_led = on
     tmr1register = 0           -- set timer0 registers for slowest speed
     accel_active = true        -- set during acceleration
     decel_active = false        -- reset
     _timer0_01s_on()           -- start timer1 for ramping up
     T0CON_TMR0ON = on          -- start timer0 and thus start steppermotor
     INTCON_TMR0IE = on         -- enable timer0 interupt
  
  end procedure








  
  procedure go_stepper(dword in distance) is   -- stepper speeding up in accel time to velocity speed
     if distance ==  0 | run then return end if
     run = true
                              -- and after while speeding down in decel time to stop
                              -- having totally travelled "distance" number of pulses


  _timer0_01s_on()             -- start timer1 for ramping down
  
  

  end procedure





   procedure stop_stepper() is   -- stepper speeding down in decel time to stop
     if decel_ramp == 0 then
        hold_stepper()           -- decel = 0 thus stop stepper direct
        return
     end if
     accel_active = false        -- reset
     decel_active = false        -- set during deceleration
     stop = true
     _timer0_01s_on()            -- start timer1 for ramping down
   end procedure





  procedure accel(word in data) is   -- data in is 0.1 Seconds
  --                                    calculates accelaration ramp (pulses/Sec2)
  --                                    at fixed velocity of 600rpm by formula:
  --                                    accel_ramp = ((600*step_rate)/60)*10)/data
     if data > 0 then
        accel_ramp = (step_rate*100)/data -- but simplified
     end if
  end procedure



  procedure decel(word in data) is   -- data in is 0.1 Seconds
  --                                    calculates decelaration ramp (pulses/Sec2)
  --                                    at fixed velocity of 600rpm by formula:
  --                                    decel_ramp = ((600*step_rate)/60)*10)/data
     if data > 0 then
        decel_ramp = (step_rate*100)/data -- but simplified
     end if
  end procedure


